\documentclass[14pt, a4paper]{extarticle}
\usepackage{indentfirst}
\usepackage{titulpage}
\usepackage{listings}

\textwidth 16cm
\textheight 25cm
\oddsidemargin -2.5mm
\evensidemargin -3mm
\topmargin -20mm
\parindent 1.25cm
\bibliography{sources.bib}

\begin{document}
    
    \fefutitlepage{Б9121-09.03.03пикд}{Яцевич К.А.}{2}{Февраля\hspace{30pt}}{23}
    \defaultfont
    
    \vspace{1cm}
   
    \pagebreak
   
    \tableofcontents
   
    \pagebreak

    \section*{Глоссарий}
    \addcontentsline{toc}{section}{Глоссарий}

    \textbf{Вершина(узел)} - структурная единица графа

    \textbf{Ребро} - соединяет вершины графа
    
    \textbf{Граф} - математическая система, объекты которой обладают парными связями

    \textbf{Паросочетание} - набор несмежных ребер

    \textbf{Свободная вершина} - вершина графа, не покрытая паросочетанием

    \textbf{Дополняющий(увеличивающий) путь} - чередующаяся цепь, которая начинается и кончается голыми вершинами.

    \textbf{Цветок(соцветие/бутон)} - нечетный цикл графа

    \textbf{Стебель} - чередующаяся цепь чётной длины

    \textbf{База} - вершина графа, которая пренадлежит стеблю и  является частю цикла

    \pagebreak
   
    \section*{Введение}
    \addcontentsline{toc}{section}{Введение}
   
    % \textit{Цель:} Научиться определять тип ДУ, пользоваться методом Эйлера, и с помощью программ компьютерной математики научиться решать представленные ниже задачи.\\
   
    % \subsection*{Постановка задачи}
    % Требуется разработать алгоритм  за ассимтотику $O(n^3)$. Провести тестирование с использованием ручных тестов и тестов с использованием генератора.
   
    \subsection*{Историческая справка}
    \addcontentsline{toc}{subsection}{Историческая справка}
   
    Алгоритм разработал Джек Эдмондс в 1961 году и опубликовал в 1965 году. 
    
    Основной причиной, почему алгоритм сжатия цветков важен, является то, что он дал первое доказательство возможности нахождения наибольшего паросочетания за полиномиальное время. Другой причиной является то, что метод приводит к описанию многогранника линейного программирования для многогранника паросочетаний, что приводит к алгоритму паросочетания минимального веса. 
    
    Как уточнил Александр Схрейвер, дальнейшая важность результата следует из факта, что этот многогранник был первым, доказательство целочисленности которого «не просто следовало из тотальной унимодулярности, а его описание было прорывом в комбинаторике многогранников».

    \pagebreak
    
    \section*{Описание алгоритма}
    \addcontentsline{toc}{section}{Описание алгоритма}

    \subsection*{Идея алгоритма}
    \addcontentsline{toc}{subsection}{Идея алгоритма}
    
    Алгоритм сжатия цветков (англ. Blossom algorithm) — это алгоритм в теории графов для построения наибольших паросочетаний на графах.
    
    Если дан граф $G=(V, E)$ общего вида, алгоритм находит паросочетание M такое, что каждая вершина из $V$ инцидентна не более чем одному ребру из $M$ и $|M|$ максимально. Паросочетание строится путем итеративного улучшения начального пустого паросочетания вдоль увеличивающих путей графа. 
    
    В отличие от двудольного паросочетания ключевой новой идеей было сжатие нечетного цикла в графе (цветка) в одну вершину с продолжением поиска итеративно по сжатому графу.

    \subsection*{Оценка сложности}
    \addcontentsline{toc}{subsection}{Оценка сложности}

    Всего имеется $n$ итераций, на каждой из которых выполняется обход в ширину за $O(m)$ кроме того, могут происходить операции сжатия цветков — их может быть $O(n)$. Сжатие соцветий работает за $O(n)$, то есть общая асимптотика алгоритма составит $O(n(m+n^2))=O(n^3)$.

    \subsection*{Нахождение дополняющего(увеличивающего) пути}
    \addcontentsline{toc}{subsection}{Нахождение дополняющего(увеличивающего) пути}

    Пусть зафиксировано некоторое паросочетание $M$. Тогда простая цепь $P = (v_1, v_2, \ldots, v_k)$ называется чередующейся цепью, если в ней рёбра по очереди принадлежат - не принадлежат паросочетанию $M$. Чередующаяся цепь называется увеличивающей, если её первая и последняя вершины не принадлежат паросочетанию. Иными словами, простая цепь $P$ является увеличивающей тогда и только тогда, когда вершина $v_1 \not\in M$, ребро $(v_2,v_3) \in M$, ребро $(v_4,v_5) \in M$, ..., ребро $(v_{k-2},v_{k-1}) \in M$, и вершина $v_k \not\in M$.

    Мы сможем найти максимальное парасочитание путем инверсии дополняющего пути.

    Основная проблема заключается в том, как находить увеличивающий путь. Если в графе имеются циклы нечётной длины, то просто обход в глубину/ширину будет работать не корректно - при попадании в цикл нечётной длины обход может пойти по циклу в неправильном направлении.

    \pagebreak

    \subsection*{Сжатие цветка}
    \addcontentsline{toc}{subsection}{Сжатие цветка}

    \textbf{Сжатие цветка} — это сжатие всего нечётного цикла в одну псевдо-вершину (соответственно, все рёбра, инцидентные вершинам этого цикла, становятся инцидентными псевдо-вершине).
    
    \subsection*{Теорема Эдмондса}
    \addcontentsline{toc}{subsection}{Теорема Эдмондса}
    
    В графе $\overline G$ существует увеличивающая цепь тогда и только тогда, когда существует увеличивающая цепь в $G$.

    \textit{Доказательство}. 
    
    Итак, пусть граф $\overline G$ был получен из графа G сжатием одного цветка (обозначим через B цикл цветка, и через $\overline B$ соответствующую сжатую вершину), докажем утверждение теоремы. Вначале заметим, что достаточно рассматривать случай, когда база цветка является свободной вершиной (не принадлежащей паросочетанию). Действительно, в противном случае в базе цветка оканчивается чередующийся путь чётной длины, начинающийся в свободной вершине. Прочередовав паросочетание вдоль этого пути, мощность паросочетания не изменится, а база цветка станет свободной вершиной. Итак, при доказательстве можно считать, что база цветка является свободной вершиной.
    
    Теперь допустим, что $M′$ не является наибольшим паросочетанием в графе $G′$. Обозначим через $N′$ паросочетание в $G′$, мощности большей, чем $M′$. Восстановим граф $G$, тогда $N′$ будет соответствовать некоторому паросочетанию в $G$, покрывающему не более одной вершины в $Z$. Следовательно паросочетание $N′$ можно увеличить, используя $k$ рёбер цикла $Z$, и получить паросочетание $N$, размера $|N|=|N′|+k>|M′|+k=|M|$, то есть $M$ не является наибольшим паросочетанием в $G$, приходим к противоречию. Таким образом теорема доказана.

    \pagebreak
    
    \subsection*{Общая схема алгоритма}
    \addcontentsline{toc}{subsection}{Общая схема алгоритма}

    \begin{lstlisting}[language=Python, basicstyle=\footnotesize\ttfamily, frame=single]
void edmonds() 
    for (int i=0; i<n; ++i) 
        if (vertex i not_in_pairing) 
            int last_v = find_augment_path (i);
            if (last_v != -1) 
                do alternation along the way from i to last_v

                
int find_augment_path(int root) 
    bfs
    int v = current_vertex
    enumeration_of_all_edges in v
        if edges_cycle_len is odd --> compress blossom
        if find free vertex--> return augment path
        if find not free vertex -->
                                add in turn adjacent vertex in matching
    return -1
    \end{lstlisting}

    \pagebreak
    
    \subsection*{Пример работы алгоритма}
    \addcontentsline{toc}{subsection}{Пример работы алгоритма}


    \begin{figure}[h!]
        \centering
        \includegraphics[scale=0.3]{1.png}
        \caption{Исходный график}
        \label{fig:my_label}
    \end{figure}

    Начинаем рассматривать граф со свободной вершины 7. Двигаясь по ребрам обнаруживаем стебель: ребра 7-2 и  2-9. Следовательно, предполагаемый дополняющий путь будет начинаться со свободной вершины 7, ребро 2-9 - паросочетание. Тогда вершина 9 является базой. С помощию BFS идем дальшне по графу:
    ребро 9-5, ребро 5-4, ребро 4-9 - составляют нечетный цикл - цветок.
    
    \begin{figure}[h!]
        \centering
        \includegraphics[scale=0.3]{2.png}
        \caption{Нахождение первого цветка}
        \label{fig:my_label}
    \end{figure}

    
    Вершины цикла сжимаем в базу. Получаем следующий граф, который продолжаем обрабатывать по тому же алгоритму.
    С помощию BFS идем дальше по графу:
    ребро 9-3, ребро 3-1, ребро 1-9 - составляют нечетный цикл - цветок.

    \begin{figure}[h!]
        \centering
        \includegraphics[scale=0.3]{3.png}
        \caption{Нахождение второго цветка}
        \label{fig:my_label}
    \end{figure} 

    \pagebreak

    Вершины цикла сжимаем в базу. Новый  граф снова обрабатываем.
    Ребра 9-8 8-0 и 0-9 - составляют нечетный цикл - цветок.

    \begin{figure}[h!]
        \centering
        \includegraphics[scale=0.3]{4.png}
        \caption{Нахождение третьего цветка}
        \label{fig:my_label}
    \end{figure} 

    Сжимаем цветок и продолжаем анализировать граф. После базы 9 идет только одно ребро 9-6, окончание которого - свободная вершина 6. Следовательно можем утверждать, что мы нашли дополняющий путь: 7-2, 2-9, 9-6.

    \begin{figure}[h!]
        \centering
        \includegraphics[scale=0.3]{5.png}
        \caption{Дополняющий путь}
        \label{fig:my_label}
    \end{figure} 

    \pagebreak

    Обращаемся к теореме Эдмондса:
    
    В графе $\overline G$ существует увеличивающая цепь тогда и только тогда, когда существует увеличивающая цепь в $G$.

    Значит мы можем приступить к восстановлению графа путем последовательного возвращения цветков.
    Для нахождения максимального паросочетания начнём с инверсии дополняющего пути.
    Начинаем восстановление с последнего сжатия цветка, инвертируя путь. При этом инвертрование пути подразумевает переопределение паросочетания. В цветке мы определяем паросочетание "в обратной последовательности": начиная с 9-0, переходя к 0-8. Так как в дополняющем пути база 9 была соединена с вершиной 6, то дойдя до узла, соединенного с вершиной 6, мы продолжаем переопределять паросочетание в направлении вершины 6.

    На данном этапе паросочетание составляет следующие не инцидентные ребра:
    7-2, 9-0, 8-6

    \pagebreak
    
    \begin{figure}[h!]
        \centering
        \includegraphics[scale=0.3]{6.png}
        \caption{Восстановление третьего цветка}
        \label{fig:my_label}
    \end{figure} 

    Запоминаем проставленное паросочетание и продолжаем восстановление графа. Ребро 7-2 уже инвертированно, поэтому переходим сразу к базе: в цветке определяем паросочетание "в обратной последовательности". База уже относится к ребру паросочетания, поэтому мы не можем пометить ребро 9-1. Значит помечаем следующее ребро 1-3. Аналогично с ребром 3-9.  

    На данном этапе паросочетание составляет следующие не инцидентные ребра:
    7-2, 9-0, 8-6, 3-1
    
    \begin{figure}[h!]
        \centering
        \includegraphics[scale=0.3]{7.png}
        \caption{Восстановление второго цветка}
        \label{fig:my_label}
    \end{figure} 

    \pagebreak

    Восстанавливаем последний цветок: аналогично помечаем ребра, начиная с базы. Ребро 9-4 - не помечаем, ребро 4-5 - помечаем, ребро 5-9 - не помечаем. 

    \begin{figure}[ht!]
        \centering
        \includegraphics[scale=0.3]{8.png}
        \caption{Восстановление перого цветка}
        \label{fig:my_label}
    \end{figure} 

    Мы закончили восстановление графа и нашли максимальное паросочетание.
    
    % \subsection*{Описание реализации}
    % \addcontentsline{toc}{subsection}{Описание реализации}

    % \subsection*{Возможная оптимизация}
    % \addcontentsline{toc}{subsection}{Возможная оптимизация}
    
    % \subsection*{Тестирование и анализ производительности}
    % \addcontentsline{toc}{subsection}{Тестирование и анализ производительности}

    \printbibliography
    
\end{document}